\subsection{GRASP implementation}

\subsubsection{Constructive phase}

The GRASP meta-heuristic has a constructive phase that is concerned to build up a feasible solution. This phase can be deterministic or include a certain amount of randomness by controlling a paremeter value $\alpha$.  This means
that for every execution, different solution could emerge. We use the basic GRASP construction phase described in \cite{grasp}. The specific parts of the implementation are the initialization of the candidate set $C$, implemented in the function $initializeCandidates$ depicted in $Algorithm$ $1$, and the greedy cost function shown in the next subsection.

\begin{algorithm}[H]
\KwIn{nNurses, hours, schedule\_constraints}
%\Parameter{Some parameter}
\KwOut{candidate list C}    

\SetKwData{Left}{left}
\SetKwData{This}{this}
\SetKwData{Up}{up}
\SetKwFunction{Union}{Union}
\SetKwFunction{FindCompress}{FindCompress}

$C$ $\leftarrow$ $\emptyset$ \\
\ForEach{$h \in hours$}{
	
	$E$ $\leftarrow$ $initializeEmptySchedules(10, hours, schedule_constraints)$ \\
	\ForEach{$hindex \in [h+1, hours]$}{ 
		$modulo\_param = 2$ \\
		\ForEach{$e \in E$}{
			\If{$hindex - h \bmod  modulo\_param > 0$}{
				addWorkingHour(e, hindex) \\
				\If{notValidConstraints(e)}{
					removeWorkingHour(e,hindex) \\
					addRestingHour(e, hindex)  \\
				}
			}
			\Else{
				addRestingHour(e, hindex) \\
				\If{notValidConstraints(e)}{
					removeRestigHour(e,hindex) \\
					addWorkingHour(e, hindex) \\
				}
			}

			\If{notValidConstraints(e, hindex - h)}{

				$E$ $\leftarrow$ $E \cap e$ \\
			}
			$modulo\_param += 1$
		}
	}
	$C$ $\leftarrow$ $C \cup E$
} 
$\textbf{return}$ <$C$>
\caption{initializeCandidates}\label{alg.mainLoop}
\end{algorithm}


The ComputeCandidateElements function takes as input the total number of nurses, the number of hours to schedule and the rest of the constraints(maximum presence hours, consecutive hours, total hours and minimum hours). The output is a list of multiple schedules that each nurse can be assigned to. A schedule is the list of hours in which a nurse works must work.\\
First, the algorithm initializes an empty candidate set. 
Then, for each hour in the schedule, it creates 10 different types of schedules beginning a this specific hour(line3). The difference between the 10 types of schedules is the compactness of the working hours. This is controlled by a parameter used to do the modulo with current hour index in the built schedule. This allows to create from the most compact schedule with all working hours consecutive until the constraints allows to do it ($hindex - h \bmod hours + 1$), to the most sparse schedule consisting of alternating working and resting hours (using $ hindex -h  \bmod 2$).
The different schedules, started at different hours are built incrementally by adding work or rest hours depending on the modulo parameter (line 7), and always taking into consideration the validity of the resulting partial schedule (line 9, 16), in which case the validity is temptatively fixed. If no more options remain and the schedule becomes invalid for the constraints of the problem(line 21), it is removed from the set $E$ (line 22) and so it is not later saved to the candidate set $C$ (line 27).

\subsubsection{Greedy cost function}

As all the nurses are equal in this scenario, there's only one thing that the greedy cost function can determine, the number of hours of demand that a single nurse schedule contributes to. We are able to do this because all schedule candidates produced are valid (they follow the constraints). We conside $e$ to be a candidate schedule for a single nurse, being $e_{h} = 1$ if the nurse has to work or 0 otherwise. We also use a big constant number K, that should be bigger than the value $hours$ (for example $nNurses$) and we consider $remaining\_demand_h$ to be the demand that is not covered by any other schedule that is present in the solution at the hour $h$	.

\begin{center}
 $ gc(e) = K - \sum_{h=1}^{Hours} remaining\_demand_h \times e_{h}$
\end{center}

\subsubsection{Other problem specific details}

There are some specific modifications of the GRASP constructie phase of \cite{grasp} applied to this problem. After updating the candidate set, in \cite{grasp} page 2, we test the feasibility of the updated solution in each iteration of the constructive phase, and in the case we are having a feasible solution, we leave the loop. If not, we continue looping until no candidate schedules are available or no more candidate schedules can be added (all nurses have a schedule). A solution is feasible if for each hour, the demand is less or equal to the number of nurses working at this hour. Another improvement introduced in the basic version of the algorithm, is the fact that instead of removing candidate elements(single nurse schedules) from the candidate set and adding them to the solution, we generate a basic list of possible candidates and each time a nurse is assigned one of them, we don't remove it from the candidate set. What we do is recompute each time the greedy cost of each candidate when the solution is updated. This is possible thanks to the fact that all nurses are equal under the problem assumptions and constraints. That way we reduce the number of candidates that we have to generate and sort.



\subsubsection{Local Search}

The other part that will be shown is about the local search. Once the constructive phase ends up with a solution, eventually it is the optimal, but usually it is not. In order to improve the solution a neighbourhoods of the constructive phase solution, i.e. near solutions will be searched. This phase is called local search. You can see the pseudocode 4.1.3 for the implemented local search procedure.

In the intensive Local Search ($Algorithm$ $3$) we take as input an incumbent solution, the max number of failed iterations for this Local Search procedure and finally the parameters of the problem instance (number of nurses, number of hours, demand per hour). As output a solution is returned.

The procedure starts by initializing the number of failed iterations ($failedIterations$) to 0 (line 1). Now we iterate while the number of failed iterations is less than the number of max failed iterations (line 2). Inside the loop, we start by calculating an auxiliary solution by applying a first improvement local search over the incumbent solution (line 3). We check if the used nurses (objective function of the problem) of the auxiliary solution we have just got from the first improvement local search is greater or equal than the  used nurses by the incumbent solution (line 4), this means that the intensified solution is of the same quality or worse than the previous solution, so in this case we have failed to intensify the solution and get a better one, so the failed iterations counter is increased by 1 (line 5). Otherwise we successfully got a better solution by intensification so the failed iterations counter is reinitialized to 0. At the end of the loop, the incumbent solution is replaced by the auxiliary solution found (line 11) and returned as solution (line 12).

\begin{algorithm}[H]
\KwIn{incumbentSolution, maxFailedIterations, nNurses, hours, demand}
%\Parameter{Some parameter}
\KwOut{solution}    

\SetKwData{Left}{left}
\SetKwData{This}{this}
\SetKwData{Up}{up}
\SetKwFunction{Union}{Union}
\SetKwFunction{FindCompress}{FindCompress}

failedIterations $\leftarrow$ 0 \\
\While{$failedIterations$ $<$ $maxFailedIterations$}{
solution' $\leftarrow$ firstImprovementLocalSearch(incumbentSolution, nNurses, hours, demand) \\
\If{getUsedNurses(solution') $\geq$ getUsedNurses(incumbentSolution)}{\label{lt}
failedIterations += 1
}
\Else{failedIterations = 0}{\label{lt}
}
}
incumbentSolution $\leftarrow$ solution'\\
$\textbf{return}$ incumbentSolution
\caption{Intensive Local Search}\label{alg.mainLoop}
\end{algorithm}

\begin{algorithm}[H]
\KwIn{solution, nNurses, hours, demand}
%\Parameter{Some parameter}
\KwOut{solution}    

\SetKwData{Left}{left}
\SetKwData{This}{this}
\SetKwData{Up}{up}
\SetKwFunction{Union}{Union}
\SetKwFunction{FindCompress}{FindCompress}
solution' $\leftarrow$ solution \\
computeExceedingNurseHours(solution', nNurses, hours, demand) \\
exceedingCapacityRemoval(solution', nNurses, hours, demand) \\
improved $\leftarrow$ $\textbf{TRUE}$ \\
\While{$improved$}{
improved $\leftarrow$ $\textbf{FALSE}$ \\
findRestschedules(solution, nNurses, hours, demand) \\
\ForEach{$n$ $\in$ $nNurses$}{\label{lt}
solution' $\leftarrow$ exchangeWorkingHours(n) \\
\If{isNotFeasible(solution', nNurses, hours, demand)}{\label{lt}
$\textbf{break}$
}
\ElseIf{getUsedNurses(solution') $<$ getUsedNurses(solution)}{\label{lt}
improved $\leftarrow$ $\textbf{TRUE}$ \\
}
}
}
solution $\leftarrow$ solution'\\
$\textbf{return}$ solution
\caption{First Improvement Local Search}\label{alg.mainLoop}
\end{algorithm}


