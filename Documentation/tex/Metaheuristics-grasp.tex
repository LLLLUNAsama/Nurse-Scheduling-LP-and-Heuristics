\subsection{GRASP implementation}

\subsubsection{Constructive phase}

The GRASP meta-heuristic has a constructive phase that is concerned to build up a feasible solution. This phase can be deterministic or include a certain amount of randomness by controlling a paremeter value $\alpha$.  This means
that for every execution, different solution could emerge.

% \makeatletter 
% \g@addto@macro{\@algocf@init}{\SetKwInOut{Parameter}{Parameters}} 
% \makeatother

% Explain GRASP constructive 

% \begin{algorithm}[H]
% \KwIn{nNurses, hours, demand}
% %\Parameter{Some parameter}
% \KwOut{<solution, cost>}    

% \SetKwData{Left}{left}
% \SetKwData{This}{this}
% \SetKwData{Up}{up}
% \SetKwFunction{Union}{Union}
% \SetKwFunction{FindCompress}{FindCompress}

% solution $\leftarrow$ $\emptyset$ \\
% E $\leftarrow$ $computeCandidateElements(nNurses, hours, demand)$ \\
% \While{$E$ $\neq$ $\emptyset$}{
% computeGreedyCost(solution, E, nNurses, hours, demand) \\
% min\_gc $\leftarrow$ min(e.gc | e $\in$ E) \\
% max\_gc $\leftarrow$ max(e.gc | e $\in$ E) \\
% RCL $\leftarrow$ \{ e $\in$ E | e.gc < min\_gc + (max\_gc - min\_gc) $\times$ $\alpha$ \} \\
% e $\leftarrow$ randomSelection(RCL) \\
% solution $\leftarrow$ solution $\cup$ {e} \\
% \If{isFeasible(solution, nNurses, hours, demand)}{\label{lt}
% $\textbf{break}$
% }
% }
% cost $\leftarrow$ computeObjectiveFunctionCost(solution)\\
% $\textbf{return}$ <solution,cost>
% \caption{GRASP constructive phase}\label{alg.mainLoop}
% \end{algorithm}

We use the basic GRASP construction phase described in \cite{grasp}. The specific part of the implementation is the initialization of the candidate set $C$, implemented in the function $computeCandidateElements$ depicted in $Algorithm$ $2$, and the greedy cost function shown in the next subsection.

\begin{algorithm}[H]
\KwIn{nNurses, hours, demand}
%\Parameter{Some parameter}
\KwOut{<solution, cost>}    

\SetKwData{Left}{left}
\SetKwData{This}{this}
\SetKwData{Up}{up}
\SetKwFunction{Union}{Union}
\SetKwFunction{FindCompress}{FindCompress}

solution $\leftarrow$ $\emptyset$ \\
E $\leftarrow$ $computeCandidateElements(nNurses, hours, demand)$ \\
\While{$E$ $\neq$ $\emptyset$}{
computeGreedyCost(solution, E, nNurses, hours, demand) \\
min\_gc $\leftarrow$ min(e.gc | e $\in$ E) \\
max\_gc $\leftarrow$ max(e.gc | e $\in$ E) \\
RCL $\leftarrow$ \{ e $\in$ E | e.gc < min\_gc + (max\_gc - min\_gc) $\times$ $\alpha$ \} \\
e $\leftarrow$ randomSelection(RCL) \\
solution $\leftarrow$ solution $\cup$ {e} \\
\If{isFeasible(solution, nNurses, hours, demand)}{\label{lt}
$\textbf{break}$
}
}
cost $\leftarrow$ computeObjectiveFunctionCost(solution)\\
$\textbf{return}$ <solution,cost>
\caption{computeCandidateElements}\label{alg.mainLoop}
\end{algorithm}


The ComputeCandidateElements function takes as input the total number of nurses, the number of hours to schedule, the demand per hour and the rest of the constraints(maximum presence hours, consecutive hours, total hours and minimum hours). The output is a list of multiple schedules that each nurse can be assigned to. A schedule is the list of hours in which a nurse works must work.




There are some specific modifications of the GRASP constructie phase of \cite{grasp} applied to this problem. After updating the candidate set, in \cite{grasp} page 2, we test the feasibility of the updated solution in each iteration of the constructive phase, and in the case we are having a feasible solution, we leave the loop. If not, we continue looping until no candidate schedules are available or no more candidate schedules can be added (all nurses have a schedule). A solution is feasible if for each hour, the demand is less or equal to the number of nurses working at this hour.
 
Another improvement introduced in the basic version of the algorithm, is the fact that instead of removing candidate elements(single nurse schedules) from the candidate set and adding them to the solution, we generate a basic list of possible candidates and each time a nurse is assigned one of them, we don't remove it from the candidate set. What we do is recompute each time the greedy cost of each candidate when the solution is updated. That way we reduce the number of candidates that we have to generate and sort.



\subsubsection{Local Search}

The other part that will be shown is about the local search. Once the constructive phase ends up with a solution, eventually it is the optimal, but usually it is not. In order to improve the solution a neighbourhoods of the constructive phase solution, i.e. near solutions will be searched. This phase is called local search. You can see the pseudocode 4.1.3 for the implemented local search procedure.

In the intensive Local Search ($Algorithm$ $3$) we take as input an incumbent solution, the max number of failed iterations for this Local Search procedure and finally the parameters of the problem instance (number of nurses, number of hours, demand per hour). As output a solution is returned.

The procedure starts by initializing the number of failed iterations ($failedIterations$) to 0 (line 1). Now we iterate while the number of failed iterations is less than the number of max failed iterations (line 2). Inside the loop, we start by calculating an auxiliary solution by applying a first improvement local search over the incumbent solution (line 3). We check if the used nurses (objective function of the problem) of the auxiliary solution we have just got from the first improvement local search is greater or equal than the  used nurses by the incumbent solution (line 4), this means that the intensified solution is of the same quality or worse than the previous solution, so in this case we have failed to intensify the solution and get a better one, so the failed iterations counter is increased by 1 (line 5). Otherwise we successfully got a better solution by intensification so the failed iterations counter is reinitialized to 0. At the end of the loop, the incumbent solution is replaced by the auxiliary solution found (line 11) and returned as solution (line 12).

\begin{algorithm}[H]
\KwIn{incumbentSolution, maxFailedIterations, nNurses, hours, demand}
%\Parameter{Some parameter}
\KwOut{solution}    

\SetKwData{Left}{left}
\SetKwData{This}{this}
\SetKwData{Up}{up}
\SetKwFunction{Union}{Union}
\SetKwFunction{FindCompress}{FindCompress}

failedIterations $\leftarrow$ 0 \\
\While{$failedIterations$ $<$ $maxFailedIterations$}{
solution' $\leftarrow$ firstImprovementLocalSearch(incumbentSolution, nNurses, hours, demand) \\
\If{getUsedNurses(solution') $\geq$ getUsedNurses(incumbentSolution)}{\label{lt}
failedIterations += 1
}
\Else{failedIterations = 0}{\label{lt}
}
}
incumbentSolution $\leftarrow$ solution'\\
$\textbf{return}$ incumbentSolution
\caption{Intensive Local Search}\label{alg.mainLoop}
\end{algorithm}

\begin{algorithm}[H]
\KwIn{solution, nNurses, hours, demand}
%\Parameter{Some parameter}
\KwOut{solution}    

\SetKwData{Left}{left}
\SetKwData{This}{this}
\SetKwData{Up}{up}
\SetKwFunction{Union}{Union}
\SetKwFunction{FindCompress}{FindCompress}
solution' $\leftarrow$ solution \\
computeExceedingNurseHours(solution', nNurses, hours, demand) \\
exceedingCapacityRemoval(solution', nNurses, hours, demand) \\
improved $\leftarrow$ $\textbf{TRUE}$ \\
\While{$improved$}{
improved $\leftarrow$ $\textbf{FALSE}$ \\
findRestschedules(solution, nNurses, hours, demand) \\
\ForEach{$n$ $\in$ $nNurses$}{\label{lt}
solution' $\leftarrow$ exchangeWorkingHours(n) \\
\If{isNotFeasible(solution', nNurses, hours, demand)}{\label{lt}
$\textbf{break}$
}
\ElseIf{getUsedNurses(solution') $<$ getUsedNurses(solution)}{\label{lt}
improved $\leftarrow$ $\textbf{TRUE}$ \\
}
}
}
solution $\leftarrow$ solution'\\
$\textbf{return}$ solution
\caption{First Improvement Local Search}\label{alg.mainLoop}
\end{algorithm}

\subsubsection{Greedy cost function}

Finally, an important function for this meta-heuristic is the greedy function. This greedy function is giving us information about the quality of a candidate in order to decide if this candidate should
be part of the solution or not. In this case, the greedy value depends on ... BRIEF

\begin{center}
q = $(\sum_{h=1}^{nHours} demand_h \times w_{n,h})^{-1}$
\end{center}

