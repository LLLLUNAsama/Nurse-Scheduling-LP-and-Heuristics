\subsection{GRASP implementation}

\subsubsection{Constructive phase}

The GRASP meta-heuristic has a constructive phase that is concerned to build up a feasible solution. This phase is not deterministic because the randomness done on the candidate pick process. It means
that for every execution, different solution could be emerge. This part is based on a randomized greedy algorithm, so a greedy function is also needed.

You can see the constructive phase into two pseudo-codes. The constructive phase itself is at pseudocode X. But in order to understand better what the developed heuristic is doing, you can
see how the candidates set is generated at pseudocode Y.

The essential idea is ... very brief here pls!.

\makeatletter 
\g@addto@macro{\@algocf@init}{\SetKwInOut{Parameter}{Parameters}} 
\makeatother

Explain GRASP constructive

\begin{algorithm}[H]
\KwIn{nNurses, hours, demand}
%\Parameter{Some parameter}
\KwOut{<solution, cost>}    

\SetKwData{Left}{left}
\SetKwData{This}{this}
\SetKwData{Up}{up}
\SetKwFunction{Union}{Union}
\SetKwFunction{FindCompress}{FindCompress}

solution $\leftarrow$ $\emptyset$ \\
E $\leftarrow$ $computeCandidateElements(nNurses, hours, demand)$ \\
\While{$E$ $\neq$ $\emptyset$}{
computeGreedyCost(solution, E, nNurses, hours, demand) \\
min\_gc $\leftarrow$ min(e.gc | e $\in$ E) \\
max\_gc $\leftarrow$ max(e.gc | e $\in$ E) \\
RCL $\leftarrow$ \{ e $\in$ E | e.gc < min\_gc + (max\_gc - min\_gc) $\times$ $\alpha$ \} \\
e $\leftarrow$ randomSelection(RCL) \\
solution $\leftarrow$ solution $\cup$ {e} \\
\If{isFeasible(solution, nNurses, hours, demand)}{\label{lt}
$\textbf{break}$
}
}
cost $\leftarrow$ computeObjectiveFunctionCost(solution)\\
$\textbf{return}$ <solution,cost>
\caption{GRASP constructive phase}\label{alg.mainLoop}
\end{algorithm}

In the $computeCandidateElements$ function depicted in $Algorithm$ $2$, we take as an input the number of nurses available, the number of hours to schedule and the demand per hour. As output we give a solution and it's cost.

The algorithm starts by initializing an empty solution (line 1), then the candidate elements for the given problem parameters are calculated. A candidate element is a nurse assignment. So, while the candidate elements set $E$ is not empty (line 3) we are going to iterate in a loop. In this loop we start by calculating the greedy cost (line 4) of each element in the candidate set, and after that we compute the minimum greedy cost (line 5) and the maximum greedy cost (line 6), in order to calculate the restricted candidate list (line 7). After that, a candidate element is chosen at random from the restricted candidate list (line 8) and is added to the solution (line 9). We test the feasibility of this new solution (line 10), and in the case of validity we leave the loop so that at this point we have a valid and feasible solution, if not, continue looping until no candidates are available and the previous condition has not been reached.

\begin{algorithm}[H]
\KwIn{nNurses, hours, demand}
%\Parameter{Some parameter}
\KwOut{<solution, cost>}    

\SetKwData{Left}{left}
\SetKwData{This}{this}
\SetKwData{Up}{up}
\SetKwFunction{Union}{Union}
\SetKwFunction{FindCompress}{FindCompress}

solution $\leftarrow$ $\emptyset$ \\
E $\leftarrow$ $computeCandidateElements(nNurses, hours, demand)$ \\
\While{$E$ $\neq$ $\emptyset$}{
computeGreedyCost(solution, E, nNurses, hours, demand) \\
min\_gc $\leftarrow$ min(e.gc | e $\in$ E) \\
max\_gc $\leftarrow$ max(e.gc | e $\in$ E) \\
RCL $\leftarrow$ \{ e $\in$ E | e.gc < min\_gc + (max\_gc - min\_gc) $\times$ $\alpha$ \} \\
e $\leftarrow$ randomSelection(RCL) \\
solution $\leftarrow$ solution $\cup$ {e} \\
\If{isFeasible(solution, nNurses, hours, demand)}{\label{lt}
$\textbf{break}$
}
}
cost $\leftarrow$ computeObjectiveFunctionCost(solution)\\
$\textbf{return}$ <solution,cost>
\caption{computeCandidateElements}\label{alg.mainLoop}
\end{algorithm}


\subsubsection{Local Search}

The other part that will be shown is about the local search. Once the constructive phase ends up with a solution, eventually it is the optimal, but usually it is not. In order to improve the solution a neighbourhoods of the constructive phase solution, i.e. near solutions will be searched. This phase is called local search. You can see the pseudocode 4.1.3 for the implemented local search procedure.

In the intensive Local Search ($Algorithm$ $3$) we take as input an incumbent solution, the max number of failed iterations for this Local Search procedure and finally the parameters of the problem instance (number of nurses, number of hours, demand per hour). As output a solution is returned.

\begin{algorithm}[H]
\KwIn{incumbentSolution, maxFailedIterations, nNurses, hours, demand}
%\Parameter{Some parameter}
\KwOut{solution}    

\SetKwData{Left}{left}
\SetKwData{This}{this}
\SetKwData{Up}{up}
\SetKwFunction{Union}{Union}
\SetKwFunction{FindCompress}{FindCompress}

failedIterations $\leftarrow$ 0 \\
\While{$failedIterations$ $<$ $maxFailedIterations$}{
solution' $\leftarrow$ firstImprovementLocalSearch(incumbent, nNurses, hours, demand) \\
\If{getUsedNurses(solution') $\geq$ getUsedNurses(incumbent)}{\label{lt}
failedIterations += 1
}
\Else{}{\label{lt}
failedIterations = 0
}
}
incumbent $\leftarrow$ solution'\\
$\textbf{return}$ incumbent
\caption{Intensive Local Search}\label{alg.mainLoop}
\end{algorithm}

\begin{algorithm}[H]
\KwIn{solution, nNurses, hours, demand}
%\Parameter{Some parameter}
\KwOut{solution}    

\SetKwData{Left}{left}
\SetKwData{This}{this}
\SetKwData{Up}{up}
\SetKwFunction{Union}{Union}
\SetKwFunction{FindCompress}{FindCompress}
solution' $\leftarrow$ solution \\
computeExceedingNurseHours(solution', nNurses, hours, demand) \\
exceedingCapacityRemoval(solution', nNurses, hours, demand) \\
improved $\leftarrow$ $\textbf{TRUE}$ \\
\While{$improved$}{
improved $\leftarrow$ $\textbf{FALSE}$ \\
findRestschedules(solution, nNurses, hours, demand) \\
\ForEach{$n$ $\in$ $nNurses$}{\label{lt}
solution' $\leftarrow$ exchangeWorkingHours(n) \\
\If{isNotFeasible(solution', nNurses, hours, demand)}{\label{lt}
$\textbf{break}$
}
\ElseIf{getUsedNurses(solution') $<$ getUsedNurses(solution)}{\label{lt}
improved $\leftarrow$ $\textbf{TRUE}$ \\
}
}
}
solution $\leftarrow$ solution'\\
$\textbf{return}$ solution
\caption{First Improvement Local Search}\label{alg.mainLoop}
\end{algorithm}

\subsubsection{Greedy cost function}

Finally, an important function for this meta-heuristic is the greedy function. This greedy function is giving us information about the quality of a candidate in order to decide if this candidate should
be part of the solution or not. In this case, the greedy value depends on ... BRIEF

\begin{center}
q = $(\sum_{h=1}^{nHours} demand_h \times w_{n,h})^{-1}$
\end{center}

\pagebreak