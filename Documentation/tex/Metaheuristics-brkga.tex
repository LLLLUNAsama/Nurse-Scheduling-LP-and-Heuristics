\subsection{BRKGA implementation}

\subsubsection{Chromosome structure}

For this implementation, the chromosome will encode the order in which the hours are tried to be fulfilled with nurses. The decoder is behaving as a greedy algorithm but with some modification in order to work with the chromosome as you will see at X. Then the chromosome will have as many gens as hours, and every gen will have a value from 0 to 1. This value is the weight that modify the order of the fulfilled hours at the decoder.



\subsubsection{Decoder}

Recapping, the greedy algorithm is based on the idea to bring for every candidate a value that depicts the quality of every of them. This value is provided by the greedy function. For purely greedy algorithms, the candidates are sorted by this value and then the best one (the first one of the list) will be included on the solution. An evolution of greedy is GRASP that is randomizing the pick of a candidate with its RCL. This decoder is following the same idea, but taking as order the one given my the chromosome structure, being this order the priority of hours to fulfill.

This means that the gens are affecting to the position of the hours to fulfill in the assignment phase. Once we have all the hours sorted, the first one is picked. Notice that the decoder is deterministic. The randomness in BRKGA is not in the greedy part but in the generation of mutants.

The essential idea of the decoder algorithm described in $Algorithm$ $5$ is to diversify the solution by using the excess of nurses assignments per hour. To do so, the decoder starts by looping over each individual in the population (line 1), then compute the starting hours to fulfill demand for the individual (see $Algorithm$ $6$), and creating a solution which starts assigning nurses to hours using the computed starting hours (line 3). As said, this is repeated until all the individuals in the population have been iterated and then a fully valid solution has been built. Finally the population with the calculated assignments per individual and their fitness is returned.

\begin{algorithm}[H]
\KwIn{population, nNurses, hours, demand}
%\Parameter{Some parameter}
\KwOut{population}    

\SetKwData{Left}{left}
\SetKwData{This}{this}
\SetKwData{Up}{up}
\SetKwFunction{Union}{Union}
\SetKwFunction{FindCompress}{FindCompress}

\ForEach{$individual$ $\in$ $population$}{
startingHours $\leftarrow$ computeStartingHours(individual, nNurses, hours, demand) \\
solution $\leftarrow$ assignNurses(startingHours, nNurses, hours, demand) \\
calculateFitness(solution) \\
}
fitness $\leftarrow$ computeObjectiveFunctionCost(solution)\\
$\textbf{return}$ population
\caption{BRKGA Decoder algorithm}\label{alg.mainLoop}
\end{algorithm}

As illustrated in $Algorithm$ $6$, the function to compute the starting hours goes as follows: the function receives as input an individual, the number of nurses available in the problem instance, the hours (number of hours for the schedule) and the demands per hour. In the line 1, the algorithm starts by initializing the startingHours set to be empty, then, for each gene in the individual chromosome (line 2). Then, to compute the initial range of starting hours, we use the demanded nurses at the hour with the index corresponding to the index of the currently iterated gene. In the case that the gene value is less than 0.2 (line 5), which in a uniformly distributed context happens the 20\% of the times. On this case the range is going to be the 80\% of the total number of nurses (line 6). After this the candidate starting hour is finally computed (line 7) by multiplying the range by the gene value, taking the result as an integer value (line 7). This value represents an starting hour. Finally the starting hour is appended to the startingHours array (line 9). This whole calculation process is repeated while the chromosome has not yet been fully traversed (loop of line 2). At the end, the array with the order which will be used in order to fulfill the demands (startingHours) is returned as output (line 11).

\begin{algorithm}[H]
\KwIn{individual, nNurses, hours, demand}
%\Parameter{Some parameter}
\KwOut{startingHours}    

\SetKwData{Left}{left}
\SetKwData{This}{this}
\SetKwData{Up}{up}
\SetKwFunction{Union}{Union}
\SetKwFunction{FindCompress}{FindCompress}
startingHours $\leftarrow$ $\emptyset$ \\
\ForEach{$<gene, index>$ $\in$ $getChromosome(individual)$}{
range $\leftarrow$ $demand_{index}$ \\
startingHour $\leftarrow$ 0 \\
\If{gene $<$ 0.2}{\label{lt}
range $\leftarrow$ $\ceil*{0.8 \times nNurses}$ \\
startingHour $\leftarrow$ $(int)$(range $\times$ gene) \\ 
}
startingHours.add(startingHour) \\
}
$\textbf{return}$ startingHours
\caption{computeStartingHours}\label{alg.mainLoop}
\end{algorithm}


